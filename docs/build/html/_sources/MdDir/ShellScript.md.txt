# shell脚本

## 1. shell定义
- shell的定义：位于操作系统和应用程序之间的一个命令解释器。是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。
- shell的作用：负责把应用程序的输入命令信息解释给操作系统,将操作系统指令处理后的结果解释给应用程序。
- 查看当前系统的shell类型：`echo $SHELL`
- 查看当前系统环境支持的shell：`cat /etc/shells`
- 创建脚本：
	- 脚本命名要有意义,文件后缀是.sh
	- 脚本文件首行是而且必须是脚本解释器#!/bin/bash
	- 脚本文件解释器后面要有脚本的基本信息等内容,脚本文件中尽量不用中文注释;尽量用英文注释，防止本机或切换系统环境后中文乱码的困扰常见的注释信息：脚本名称、脚本功能描述、脚本版本、脚本作者、联系方式等
	- 脚本文件常见执行方式：bash 脚本名
	- 脚本内容执行：从上到下，依次执行
	- 成对内容的一次性写出来防止遗漏,[]中括号两端要有空格,流程控制语句一次性书写完再添加内容
	- 通过缩进让代码易读;(即该有空格的地方就要有空格)
	
## 2. linux中提供的shell解释器：
- `cat /etc/shells`
	```python
	/bin/sh：UNIX默认的shell，已经被/bin/bash取代。
	/bin/bash：Linux默认的shell。
	/sbin/nologin
	/bin/dash
	/bin/tcsh
	/bin/csh
	```
- 不同的shell解析器，功能不同，比如csh，符合c语言风格的shell解析器。Centos默认使用的是“/bin/bash”和“/bin/sh”作为shell解析器。“/bin/sh”是“/bin/bash”的软连接，两者等价。

## 3. 运行脚本：
- 脚本文件无执行权限时：
	- `bash xxx.sh`：指定先用bash解析器解析，如果bash不存在，使用默认解析器；
	- `source xxx.sh`或`. xxx.sh`：在当前shell进程下读取并执行脚本中的命令。
		```python
		source 是 Shell 内置命令的一种，它会读取脚本文件中的代码，并依次执行所有语句。你也可以理解为，source 命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限。与当前shell为同一个进程，不会新增加一个进程。可用 echo $$ 验证。
		```
- 脚本文件有执行权限时：
	- 绝对路径名运行脚本文件：
		```python
		/opt/test/test.sh：先按照脚本文件中#！指定的解析器解析，如果找不到使用默认解析。
		```
	- 相对路径名运行脚本文件：
		```python
		./xxx.sh：先按照脚本文件中#！指定的解析器解析，如果找不到使用默认解析。
		```
			
## 4. shell语法：
### 4.1. 变量
- **变量分类**：局部变量、环境(全局)变量、shell变量
	- 局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。包含普通变量和命令变量。
		- **普通变量**：
			```python
			var=value   #普通赋值方法
			var='value' #单引号只把值当字符处理，写什么内容就输出什么内容
			var="value"   #双引号会引用变量的值
			```
			- 注：赋值符两边不能有空格，若变量值本身包含了空格，则整个字符串都要用双引号、或单引号括起来。
		- **命令变量**：
			```python
			变量名=`命令`  #格式一
			变量名=$(命令) #格式二
			如：echo "today is `date`" #会打印出当前日期，执行了date命令。
			```
		- **环境(全局)变量**：在当前系统的所有环境下都能生效的变量。可通过`env`查看，只显示全局变量。
			```python
			语法：export 变量名=值
			```
- **查看变量**：
	- `$变量名` `"$变量名"` `${变量名}` `"${变量名}"`
- **截取变量值**：`${变量名:起始位置:截取长度}`
	```python
	${var:0:5} #从第1个字符开始，截取5个字符
	${var:5:5} #从第6个字符开始，截取5个字符
	${var:0-6:3} #从倒数第6个字符开始，截取之后的3个字符。
	```
- **变量默认值**：
	- `${变量a:-默认值}`：变量a如果有内容,那么就输出a的变量值,变量a如果没有内容，那么就输出默认的内容。
		```python
		#!/bin/bash
		read -p "输入：" a
		echo "${a:-1}"  不输入值打印 1 ，输入值打印值
		```
	- `${变量名+默认值}`：无论变量a是否有内容，都输出默认值。
		```python
		#!/bin/bash
		read -p "输入：" a
		echo "${a+15}"  无论输入什么值，都打印15
		```
- **清除变量值**
	- `unset 变量名`
- **shell变量**
	- shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。
		- `$0`：获取当前执行的shell脚本文件名
		- `$n`：获取当前执行的shell脚本的第n个参数值,n=1…9,当n为0时表示脚本的文件名,如果n大于9就要用大 括号括起来${10}。
			```python
			#!/bin/bash
			echo "第一个位置的参数是： $1"
			echo "第二个位置的参数是： $2"
			# 运行时 `./test.sh a b`加上参数a、b则会打印出对应位置参数。
			```
		- `$#`：获取当前脚本传入参数的个数（通常用于循环）。
		- `$@`	获取当前脚本的所有参数，组成数组。
		- `$*`：获取当前脚本的所有参数组成数组，但是当被双引号包裹时`"$*"`，所有参数会被整合为字符串。
		- `$?`：获取文件执行或者命令执行的返回状态值。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0，则证明上一个命令执行不正确了。
		- `$$`：程序本身的PID号。
		
### 4.2. 表达式
- **测试语句**
	- **应用场景**：Shell环境根据命令执行后的返回状态值`$?`来判断是否执行成功,当返回值为0,表示成功,值为其他时,表示失败。使用专门的测试工具——test命令,可以对特定条件进行测试,并根据返回值来判断条件是否成立(返回值0为成立）。
	- **语法**：`test 条件表达式`或`[ 条件表达式 ]`
		- 条件成立，状态返回值是0,条件不成立，状态返回值是1。
		- 括号[ ]与条件表达式两侧都要有空格，否者不符合规范。
	- **条件表达式**：
		- 逻辑表达式：常见的逻辑表达式有`&&` `||`
			- `[ 命令1 && 命令2 ]`：命令1执行成功，命令2执行，否则命令2不执行。
				```python
				[ 1 = 1  ] && echo "条件成立" #命令1执行成功，命令2执行。
				[ 1 = 2 ] && echo "条件成立" #命令1执行失败，命令2不执行。
				```
			- `命令1 || 命令2`：命令1执行成功，命令2不执行，命令1执行失败，命令2执行。
		- 文件表达式：`-f`判断输入内容是否是一个普通文件(不是目录和设备文件);`-d`判断输入内容是否是一个目录;`-r/w/x`判断输入内容是否可读/写/执行;`-c/b`文件是否为字符设备/块设备文件;`-s`文件是否不为空(文件大小是否不为0);`-e`文件或目录是否存在，`-h`文件是否为软链接；`-n`检测字符串长度是否不为 0，不为 0 返回 true。
			```python
			[ -f test.sh ] && echo "是文件" #当前路径下有该文件，两个命令都执行。
			[ -f /root/lspci.txt ] || echo "绝对路径" #该路径下有该文件，只执行前面的命令。
			[ -f lspci.txt ] || echo "当前路径" #当前路径下无该文件，执行后面的命令。
			```
			- 数值操作符：`-eq`相等;`-gt`大于;`-ge`大于等于;`-lt`小于;`-le`小于等于;`-ne`不等于
				- `[ n1 -eq n2 ]`：n1是否等于n2
			- 字符串运算符：`[ str1 == str2 ]`str1和str2字符串内容一致;`[ str1 != str2 ]`str1和str2字符串内容不一致;`[ -z str1 ]`检查字符串长度是否为0;`[ -n str1 ]`检查字符串长度是否不为0;`[ str ]`检查字符串是否不为空。
				```python
				[ a == a ]
				echo $?     #执行成功，返回状态值为0
				[ a != a ]
				echo $?     #执行失败，返回状态值为1
				```
			- 逻辑运算符：`-a`条件同时成立;`-o`条件任何一个成立;`!`取反
				```python
				[ $a -lt 20 -a $b -gt 100 ]
				```
		- 计算表达式：
			- 格式一：`$((计算表达式))` 只能用+-x/%和()运算符，并且只能做整数运算，表达式范围内，空格不限制。
			- 格式二：`let 计算表达式` 表达式必须是一个整体，中间不能出现空格的等特殊字符串。
			
### 4.3. 数组操作
- **定义**：用括号来表示数组,数组元素用“空格”符号分割开.定义数组的语法格式： array_name=(value1 … valuen)
	```python
	#单行定义
	li=(1 "a" "b")
	#多行定义
	li1=(1
	"a"
	"b"
	)
	#单元素定义，可以不使用连续下标，且下标的范围没有限制。
	li3[0]="f"
	li3[5]=1
	#命令定义
	li4=($(ls /opt))  #将该目录下的每一个目录名或文件名作为一个元素
	或 li4=(`ls /opt`)
	```
	- 注：bash支持一维数组(不支持多维数组)，数组元素用空格符号分割开。
	
- **数组信息查看**
	- **基于索引找内容**：`${array_name[index]}`,中括号中不能为空，会报错;不填索引和中括号默认只读取第一个元素。
		```python
		echo ${li[1]}   #打印索引为1的元素
		echo ${li[@]}或echo ${li[*]}   #打印所有元素
		```
	- **基于内容找索引**：`${!li[*]}`或`${!li[@]}` 只能获取数组的所有索引。
	- **获取长度**：`${#array_name[index]}`
		```python
		li=("abc" "qqcde" "fgh")
		echo ${#li[1]}  #获取索引为1的元素的长度
		echo ${#li[@]}  #获取所有元素的个数
		echo ${#li[*]}  #获取所有元素的个数
		```
- **合并数组**
	- `newli=(${li1[*] ${li2[*]}})`
- **数组的删改查**
	- **获取元素**：分为单元素获取，和元素部分内容获取
		- ${array_name[index]}：单元素获取
		- ${array_name[index]:pos :length} ：元素部分内容获取
			```python
			li=("abc" "qqcde" "fgh")
			echo ${li[1]:1:3}  #打印结果为qcd
			```
	- **更改元素**：分为元素内容替换和元素部分内容替换
		- 元素内容替换：`array_name[index]=值`
		- 元素部分内容替换：`${array_name[index]/old/nes}`
	- **删除数组**：分为删除单元素和删除整个数组
		- 删除单元素：`unset array_name[index]`
		- 删除整个数组：`unset array_name`
		
### 4.4. linxu常见符号
- `&`：将一个命令从前台转到后台执行。
	- 语法：`命令 &`
		```python
		sleep 4 #界面卡住4秒后消失
		sleep 4 & #后台执行，界面不会卡住
		```
- 信息符号：`1`表示正确输出的信息 `2`表示错误输出的信息 `2>&1`表示所有输出的信息

### 4.5. 简单流程控制
- **if语句**：
	```python
	#单分支
	if [ 条件 ]
	then
		指令
	fi

	#多分支
	if [ 条件 ]
	then
		指令1
	elif [ 条件2 ]
	then
		指令2
	elif [ 条件n ]
	then
		指令n
	else
		指令3
	fi
	```
- **case语句**：变量在值1时执行指令1....
	```python
	case 变量名 in
		值1)
			指令1
			;;
		值n)
			指令n
			;;
	esac
	```
- **循环语句**
	- **for语句**：`seq n1 n2`用于生成从n1到n2之间的所有整数
		```python
		# 形式一
		for 值 in 列表
		do
			执行语句
		done

		# 形式二
		for (( 初始值;限制值;执行步阶))
		do
			执行语句
		done
		```
	- **while语句**
		```python
		# 条件的类型：命令，[[ 字符串表达式 ]]，((数字表达式))
		while 条件
		do
			执行语句
		done
		```
	- **until语句**：直到条件为真时退出循环
		```python
		#条件类型：命令，[[ 字符串表达式 ]]，((数字表达式))
		until 条件
		do
			执行语句
		done
		```
	- **select in语句**：会显示出带编号的seq选项，输入不同编号执行不同功能。
		```python
		select var in seq
		do
			action
		done
		```
- **死循环**
	```python
	# 一
	for ((;;))
	...

	# 二
	while :
	...

	# 三
	while true
	...
	```
	- 循环退出：`break`跳出所有循环;`break n`跳出第n个循环(由内向外);`continue`跳出当前循环;`exit`退出当前程序
	
### 4.6. 函数
- **定义**：
	```python
	[ function ] funname() {
	command1
	...
	} 
	```
- `return`
	1. return 的作用是退出当前函数，不退出整个脚本
	2. 函数中return 后面的命令一概不执行
	3. return的值可以在函数刚执行结束的时候，用echo $? 获取
	4. return返回是有限制的,最大返回255,超过255,则从0开始计算
	5. exit代表退出整个脚本
	6. return和exit的返回值都能用echo $?获取
- - -
- - - 
## 5. set -e
- `set -e`：当命令以非零状态退出时，则退出shell。主要作用是，当脚本执行出现意料之外的情况时，立即退出，避免错误被忽略，导致最终结果不正确。
	- 当命令的返回值为非零状态时，则立即退出脚本的执行。
	- 作用范围只限于脚本执行的当前进行，不作用于其创建的子进程。
		- 在当前脚本运行其它脚本，当前脚本中的set -e 不会作用于运行的其它脚本（不是同一个进程了，如果用.或source执行其它脚本，因为是同一个进程，该脚本中的set -e仍然会对使用.或source执行的脚本生效 ）。
	- 另外，当想根据命令执行的返回值，输出对应的log时，最好不要采用set -e选项，而是通过配合exit 命令来达到输出log并退出执行的目的。
- - -
- - -
## 6. expect
- `expect`：expect是一个免费的编程工具，用来实现自动的交互式任务，而无需人为干预。说白了expect就是一套用来实现自动交互功能的软件需要自行安装。
	- 在使用expect时，以下为常用命令：
		```python
		spawn	# 启动新的进程
		expect	# 从进程接收字符串
		send	# 用于向进程发送字符串
		set	 	# 定义变量
		set timeout		# 设置超时时间
		exp_continue	# 相当于其他语言的continue，此处用于判断语句，在此处重新进行判断
		expect eof		# 表示结束交互，返回原终端所在位置。
		interact	# 与expect eof作用类似，但结束交互后，所处位置为脚本内最后所在位置
		exit	# 退出expect脚本
		```
		- `spawn`命令用来启动新的进程，spawn后的expect和send命令都是和使用spawn启动的新进程进行交互。
		- `expect`通常用来等待一个进程的反馈，我们根据进程的反馈，再使用send命令发送对应的交互命令。
		- `send`命令接收一个字符串参数，并将该参数发送到进程。
		- `interact`命令用的其实不是很多，一般情况下使用spawn、expect和send和命令就可以很好的完成我们的任务；但在一些特殊场合下还是需要使用interact命令的，interact命令主要用于退出自动化，进入人工交互。比如我们使用spawn、send和expect命令完成了ftp登陆主机，执行下载文件任务，但是我们希望在文件下载结束以后，仍然可以停留在ftp命令行状态，以便手动的执行后续命令，此时使用interact命令就可以很好的完成这个任务。
	- expect自动应答的基本步骤：
		1. 第一步: 运行一个程序或命令=>  spawn 命令信息
		2. 第二步: 识别产生信息关键字=>  expect 捕获关键字   {send  应答信息}
		3. 第三步: 根据识别关键做处理=>  send  应答信息
	- 例：
		```python
		#!/bin/bash
		/usr/bin/expect <<-EOF         # 加上<<-EOF.....EOF才能使用shell的变量。
		spawn scp -l $1 ./20G.txt root@172.30.22.113:/opt/dirtest/$1.txt
		expect "*password:"
		send "root\r"
		expect "passss"
		set timeout 200
		expect eof
		EOF
		```
- - -
- - -
## 7. shell脚本内部调用
- shell脚本中调用另一个脚本的三种方式
	1. `fork`: 如果脚本有执行权限的话，path/to/foo.sh。如果没有，sh path/to/foo.sh。
	2. `exec`: exec path/to/foo.sh
	3. `source`: source path/to/foo.sh
	- 区别：
		- `fork` 是最普通的, 就是直接在脚本里面用 path/to/foo.sh 来调用 foo.sh 这个脚本，比如如果是 foo.sh 在当前目录下，就是 ./foo.sh。运行的时候 terminal 会新开一个子 Shell 执行脚本 foo.sh（即新开一个进程），子 Shell 执行的时候, 父 Shell 还在。子 Shell 执行完毕后返回父 Shell。 子 Shell 从父 Shell 继承环境变量，但是子 Shell 中的环境变量不会带回父 Shell。
		- `exec` 与 fork 不同，不需要新开一个子 Shell 来执行被调用的脚本. 被调用的脚本与父脚本在同一个 Shell 内执行。但是使用 exec 调用一个新脚本以后, 父脚本中 exec 行之后的内容就不会再执行了,这是 exec 和 source 的区别。
		- `source`与 fork 的区别是不新开一个子 Shell 来执行被调用的脚本，而是在同一个 Shell 中执行. 所以被调用的脚本中声明的变量和环境变量, 都可以在主脚本中进行获取和使用。
- - -
- - -
## 8. 内建和外部命令
- shell命令的执行：shell命令分为 内建命令和外部命令
	- 内建命令（builtin command）是shell解释程序内建的， 由shell直接执行，不需要派生新的进程。
		- 常用的内建命令：`.(点命令)`、`bg`、`cd`、`continue`、`echo`、`exec`、`exit`、`export`、`fg`、`jobs`、`pwd`、`read`、`return`、`set`、`shift`、`test`、`times`、`trap`、`umask`、`unset`、`wait`等
	- 外部命令分为两种： 二进制代码 或 shell脚本。 shell执行外部命令时，会创建一个新的进程来执行命令。默认shell将等待直到该进程结束。
		- 常用的外部命令：`grep` `more` `cat` `mkdir` `rmdir` `ls`  `sort`  `ftp`  `telnet`  `ssh`   `ps` 等
	- Linux能通过fork()调用，创建一个新的进程，fork会创建原有进程的贮存的精确拷贝。
		- 调用fork的进程是父进程，而由fork创建的进程是子进程。shell 外部命令时，父进程通过fork创建了一个和它一模一样的子进程。
		- 对于外部二进制命令（/bin 下的都是二进制可执行文件），shell 需要一种机制，把 子进程 转换为 将要执行的命令。Linux调用execve可以实现将子shell "变身为" 外部命令，execve允许一个进程用其他外部命令的可执行代码覆盖自己。总的来说就是： shell 解释器会调用fork 自身的一个拷贝，然后调用 exec 系列函数来执行外部命令， 这样外部命令就取代了先前的子shell。
		- 对于脚本，shell解释器会fork一个子进程，子进程会检查脚本的第一行（#!/bin/sh ），找到用来执行脚本的解释程序，然后装入这个解释程序，由它解释执行脚本。解释程序可能有很多种，各种shell（Bash、Korn shell、cshell）等等。  在此解释程序是当前shell的子进程。 如果 这个解释器与当前shell使用的是同一种shell，比如都是bash，他就是当前shell的子shell。 脚本中的命令都是在子shell中运行的，不会影响当前shell的环境。
		- 使用fork函数得到的 子进程从父进程的继承了整个进程的地址空间，包括：
			- 进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。
- - -
- - -
## 9. shell中的括号
#### 9.1. 圆括号
-  **单圆括号**
	- 命令组：括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格；
		```python
		(ls /opt/;cat /etc/passwd)
		```
	- 命令替换：等同于cmd，shell扫描一遍命令行，发现了（cmd）结构，便将(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh；
		```python
		a=(command), 等同于a=`command`,得到命令输出赋值给变量a
		a=$(command),等同于a=(`command`)得到的命令输出为数组赋值给a
		```
	- 用于初始化数组：如：array=(a b c d)。

-  **双圆括号**
	- 整数扩展：这种扩展计算是整数型的计算，不支持浮点型。
		- `((exp))`结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是"假"；而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为0,假则为1；
	- 只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：`echo $((16#5f))` 结果为95 (16进位转十进制)；
	- 单纯用 `(( ))` 也可重定义变量值，比如 `a=5; ((a++))` 可将 $a 重定义为6；

	- 常用于算术运算比较，双括号中的变量可以不使用符号前缀。括号内支持多个表达式用逗号分开。只要括号中的表达式符合C语言运算规则。比如可以直接使用`for ((i=0;i<5;i++))`,如果不使用双括号,则为`for i in $(seq 0 4)`或者`for i in {0..4}`。再如可以直接使用`if ((i<5))`, 如果不使用双括号, 则为`if [ $i -lt 5 ]`。
	
#### 9.2. 方括号
-  **单方括号**
	- bash 的内部命令，`[`和`test`是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。`if/test`结构中的**左中括号是调用test的命令标识**，**右中括号是关闭条件判断的**。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。
	- `test`和`[]`中可用的比较运算符只有`==`和`!=`，两者都是用于**字符串比较**的，不可用于整数比较，**整数比较只能使用-eq，-gt**这种形式。无论是**字符串比较还是整数比较都不支持大于号小于号**。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab < bc ]，结果为真，也就是返回状态为0。`[ ]`中的逻辑与和逻辑或使用-a 和-o 表示。
	- 字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。
	- 在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。
-  **双方括号**
	- `[[`是 bash 程序语言的关键字。并不是一个命令，`[[ ]]` 结构比`[ ]`结构更加通用。在`[[`和`]]`之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。
	- 支持字符串的模式匹配，使用`=~`操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如`[[ hello == hell? ]]`，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。
	- 使用`[[ ... ]]`条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。
	- bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。

#### 9.3. 花括号
- **大括号拓展**。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。
	- 第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt；
	- 第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt。
- **代码块**，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。

#### 9.4. $()和``命令替换
- `$()`和` `` `表示命令的替换
- 原理：将对` `` `或`$()`里的内容先进行执行，然后将执行的结果代换到当前命令中，在shell中fork一个子进程区做他们括起来的命令,然后在返回父进程。
- 在编写脚本过程中尽量使用$()来进行命令替换，理由如下：
	- ` `` `很容易与`''`搞混乱;
	- 在多层次的复合替换中，` `` `必须要额外的转义字符处理（反斜线），而`$( )`比较直观;
	- `$()`的弊端是，并不是所有的类unix系统都支持这种方式，但` `` `是肯定支持的。

#### 9.5. ${}变量替换
- 含义：
	- 一般情况下，`$var`与`${var}`是没有区别的，但是用`${}`会比较精确的界定变量名称的范围。
- 变量替换
	- ${var}：变量本来的值
	- ${var:-word}：如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值；
	- ${var:+word}	如果变量 var 被定义，那么返回 word，但不改变 var 的值；
	- ${var:=word}：如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。是一种赋值默认值的常见做法；
	- ${var:?word}：如果变量 var 为空或已被删除(unset)，那么将消息word 送到标准错误输出，可利用此特性来检查是否设置了变量的值。若此替换出现在Shell脚本中，那么脚本将停止运行。
	- `#`、`##`、`%`、`%%`在`${}`中的使用
		- `file=/dir1/dir2/dir3/my.file.txt`
			- `${file#*/}`：删掉第一个 `/` 及其左边的字符串：dir1/dir2/dir3/my.file.txt
			- `${file##*/}`：删掉最后一个 `/`  及其左边的字符串：my.file.txt
			- `${file#*.}`：删掉第一个 `.`  及其左边的字符串：file.txt
			- `${file##*.}`：删掉最后一个 `.`  及其左边的字符串：txt
			- `${file%/*}`：删掉最后一个  `/`  及其右边的字符串：/dir1/dir2/dir3
			- `${file%%/*}`：删掉第一个 `/`  及其右边的字符串：(空值)
			- `${file%.*}`：删掉最后一个  `.`  及其右边的字符串：/dir1/dir2/dir3/my.file
			- `${file%%.*}`：删掉第一个  `.`   及其右边的字符串：/dir1/dir2/dir3/




## 10. $[]和$(())整数运算
- - -
- - -
## 11. shell中的常见使用
### 11.1. `=～`
- `=～`：在shell中，`=~`表示正则表达式匹配。当使用`=~`时，左操作数是一个字符串，右操作数是一个正则表达式。
	- 注：要在 `[[]]` 中使用
		```python
		str="apple"
		if [[ $str =~ a.p ]]; then
			echo "Match found!"
		else
			echo "Match not found!"
		fi
		# 以上代码中，"a.p"是一个正则表达式，可以匹配字符串"apple"。
		```
### 11.2. while read
- 依次将文件file中的每一行内容读取出来赋值给变量var，再进行do后面的语句
	```python
	while read var
	do
	...
	done < <file
	或done < <(commond)
	```

		







